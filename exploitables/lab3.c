#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <strings.h>
#include <netdb.h>
#include <sys/types.h> 
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/select.h>

#define BUFSIZE 1024
#define NUMCLIENTS 25
/*
 * error - wrapper for perror
 */
void error(char *msg) {
	perror(msg);
}

int getSocket() {
	int parentfd; 	/* parent socket */
	/* 
	 * socket: create the parent socket 
	 */
	parentfd = socket(AF_INET, SOCK_STREAM, 0);
	if (parentfd < 0) {
		error("ERROR opening socket");
	}
}

void setupParent(int parentfd, int portno, struct sockaddr_in *serveraddr) {
	int optval; /* flag value for setsockopt */

	/* 
	 * setsockopt: Handy debugging trick that lets us rerun the server immediately after we kill it; otherwise we have to wait about 20 secs. Eliminates "ERROR on binding: Address already in use" error. 
	 */
	optval = 1;
	setsockopt(parentfd, SOL_SOCKET, SO_REUSEADDR, (const void *)&optval , sizeof(int));

	/*
	 * build the server's Internet address
	 */
	bzero((char *) serveraddr, sizeof(*serveraddr));

	/* this is an Internet address */
	serveraddr->sin_family = AF_INET;

	/* let the system figure out our IP address */
	serveraddr->sin_addr.s_addr = htonl(INADDR_ANY);

	/* this is the port we will listen on */
	serveraddr->sin_port = htons((unsigned short)portno);
}

void authenticate(int childfd, char *buf) {
	int authenticated = 0;
	int canary = 1162294076;
	char password[248];

	/* Copy over the password */
	strcpy(password, buf);

	/* Compare against the password */
	if(strcmp(buf, "pass123!!@$#") == 0) {
		authenticated = 1162302031;
	}
	if(canary != 1162294076) {
		if(send(childfd, "Stack smashing detected!\n", 26, 0) != 26) {
			error("Error in send");

		}
		return;
	}
	//printf("Authenticated: %d, canary: %d\n", authenticated, canary);
	/* Check if the password was legitimate */
	if(authenticated == 1162302031) { /* Don't forget your endianness! */
		/* Send back happy message */
		if(send(childfd, "Congratulations!\n", 18, 0) != 18) {
			error("Error in send");
		}
		exit(0);
	}
	else {
		/* Send back sad message */
		if(send(childfd, "Incorrect password\n", 20, 0) != 20) {
			error("Error in send");
		}
	}
}

int main(int argc, char **argv) {
	int parentfd; 					/* parent socket */
	int childfd; 					/* child socket */
	int portno; 					/* port to listen on */
	int clientlen; 					/* byte size of client's address */
	struct sockaddr_in serveraddr; 	/* server's addr */
	struct sockaddr_in clientaddr; 	/* client addr */
	char buf[BUFSIZE]; 				/* message buffer */
	int n; 							/* message byte size */
	int client_sockets[30] = {0};	/* Client File Descriptors */
	fd_set readfds;
	int valread;					/* To be used as a value for read */
	/* 
	 * check command line arguments 
	 */
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	portno = atoi(argv[1]);

	parentfd = getSocket();

	setupParent(parentfd, portno, &serveraddr);
	/* 
	 * bind: associate the parent socket with a port 
	 */
	if (bind(parentfd, (struct sockaddr *) &serveraddr, sizeof(serveraddr)) < 0) {
		error("ERROR on binding");
	}

	/* 
	 * listen: make this socket ready to accept connection requests 
	 */
	if (listen(parentfd, NUMCLIENTS) < 0) { /* allow 5 requests to queue up */ 
		error("ERROR on listen");
	}

	/* initialize some things for the main loop */
	clientlen = sizeof(clientaddr);
	printf("Awaiting connections...");
	fflush(stdout);

	/* 
	 * main loop: wait for connection request or stdin command.
	 *
	 * If connection request, then echo input line 
	 * and close connection. 
	 * If command, then process command.
	 */
	while (1) {
		int max_sd = parentfd;
		/* 
		 * select: Has the user typed something to stdin or 
		 * has a connection request arrived?
		 */
		FD_ZERO(&readfds);					/* initialize the fd set */
		FD_SET(parentfd, &readfds); 		/* add socket fd */

		for (int i = 0; i < NUMCLIENTS; i++) {
			int sock = client_sockets[i];

			/* If this is a valid descriptor, add it! */
			if (sock > 0) {
				FD_SET(sock, &readfds);
			}

			/* Check if this is the new max */
			if (sock > max_sd) {
				max_sd = sock;
			}
		}

		if (select(max_sd+1, &readfds, 0, 0, 0) < 0) {
			error("ERROR in select");
		}

		/* if a connection request has arrived, process it */
		if (FD_ISSET(parentfd, &readfds)) {
			/* 
			 * accept: wait for a connection request 
			 */
			childfd = accept(parentfd, (struct sockaddr *) &clientaddr, &clientlen);
			if (childfd < 0) {
				error("ERROR on accept");
			}

			/* Send greeting :) */
			if(send(childfd, "Welcome! Please input your password to continue.\n", 50, 0) != 50) {
				error("Error in send");
			}
			
			/* If this is a new client, add it to the list of client sockets */
			for (int i = 0; i < NUMCLIENTS; i++ ) {
				if (client_sockets[i] == 0) {
					client_sockets[i] = childfd;
					break;
				}
			}
		}

		/* Check other sockets for requests/closings */
		for (int i = 0; i < NUMCLIENTS; i++) {
			childfd = client_sockets[i];

			if (FD_ISSET(childfd, &readfds)) {
				//check if closing
				if ((valread = read(childfd, buf, BUFSIZE)) == 0) {
					close(childfd);
					client_sockets[i] = 0;
				}

				else {
					/* Remove newline by overwriting it with a null byte */
					buf[valread] = '\0';
					authenticate(childfd, buf);
				}
			}
		}
	}

	/* clean up */
	printf("Terminating server.\n");
	close(parentfd);
	exit(0);
}
//ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss
//ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss
